---
title: "Assignment 3"
description: | 
  Pupil popularity and extraversion
date: 05-28-2021
author:
  - first_name: "Andrew"
    last_name: "Ellis"
    url: https://github.com/awellis
    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern 
    affiliation_url: https://www.kog.psy.unibe.ch
    orcid_id: 0000-0002-2788-936X

citation_url: https://awellis.github.io/learnmultilevelmodels/asssignment-3.html
bibliography: ./bibliography.bib
output: 
    distill::distill_article:
      toc: true
      toc_float: true
      toc_depth: 2
      code_folding: false
      self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r}
library(tidyverse)
library(brms)

theme_set(theme_grey(base_size = 14) +
            theme(panel.grid = element_blank()))
```


We'll look at a dataset containing popularity ratings (given by  classmates) and various personal characteristics of pupils in different classes. The data are available from the[companion website](https://multilevel-analysis.sites.uu.nl/intro-to-multilevel-analyses/) of a book on multilevel analysis [@MultilevelAnalysisTechniques].

## Download data


```{r}
popularity <- haven::read_sav(file = "https://github.com/MultiLevelAnalysis/Datasets-third-edition-Multilevel-book/blob/master/chapter%202/popularity/SPSS/popular2.sav?raw=true")
```


```{r}
popularity <- popularity |> 
  select(-starts_with("Z"), -Cextrav, - Ctexp, -Csex) |> 
  mutate(sex = haven::as_factor(sex))

popularity
```
The variables are

```
- pupil: ID
- class: which class are pupils in?
- extrav: extraversion score
- sex: gender
- texp: teacher experience
- popular: popularity rating
- popteach: teacher popularity
- Zextrav: z-transformed extraversion score           
```

You want to predict pupils' popularity using their extraversion, gender and teacher experience.

:::exercise
- You should center the predictor variables.

- How many pupils are there per class?
:::

```{r code_folding = TRUE}
popularity |> 
  group_by(class) |> 
  count()
```


```{r}
popularity |> 
  ggplot(aes(x = extrav,
           y = popular,
           col = class,
           group = class)) + 
  geom_point(size     = 1.2,
             alpha    = .8,
             position = "jitter") +
  theme(legend.position = "none") +
  labs(title = "Popularity vs. Extraversion")
```



## Intercept-only model

Start by fitting an intercept-only model.

```{r eval=FALSE, include=FALSE}
lm1 <- lme4::lmer(popular ~ 1 + (1 | class),
                data = popularity)

eq1 <- equatiomatic::extract_eq(lm1)
```

$$
\begin{aligned}
  \operatorname{popular}_{i}  &\sim N \left(\alpha_{j[i]}, \sigma^2 \right) \\
    \alpha_{j}  &\sim N \left(\mu_{\alpha_{j}}, \sigma^2_{\alpha_{j}} \right)
    \text{, for class j = 1,} \dots \text{,J}
\end{aligned}
$$


```{r code_folding = TRUE}
interceptonlymodel <- brm(popular ~ 1 + (1|class),        
                          ata = popularity, 
                          file = "models/popularity-1") 
```

```{r eval=FALSE, include=FALSE}
interceptonlymodel
```


## First level predictors


Now you can add some level 1 predictors, e.g. `sex`, `extrav`. You can use the `update()` so that you don't have to rerun the compilation steps.


```{r eval=FALSE, include=FALSE}
lm2 <- lme4::lmer(popular ~ 1 + sex + extrav + 
                (1 | class),
                data = popularity)

eq2 <- equatiomatic::extract_eq(lm2)
```

$$
\begin{aligned}
  \operatorname{popular}_{i}  &\sim N \left(\alpha_{j[i]} + \beta_{1}(\operatorname{sex}_{\operatorname{girl}}) + \beta_{2}(\operatorname{extrav}), \sigma^2 \right) \\
    \alpha_{j}  &\sim N \left(\mu_{\alpha_{j}}, \sigma^2_{\alpha_{j}} \right)
    \text{, for class j = 1,} \dots \text{,J}
\end{aligned}
$$


```{r eval=FALSE, include=TRUE, code_folding = TRUE}
interceptonlymodel |> 
  update(. ~ . + sex, 
         prior = prior(normal(0, 2), class = b),
         newdata = popularity)
```


This is equivalent to

```{r eval=FALSE, include=TRUE, code_folding = TRUE}
m2 <- brm(popular ~ 1 + sex + extrav + (1|class),  
              prior = prior(normal(0, 2), class = b),
              data = popularity) 
```




Now add both `sex` and  `extrav` as varying effecs.

```{r eval=FALSE, include=FALSE}
lm3 <- lme4::lmer(popular ~ 1 + sex + extrav + 
                (1 + sex + extrav | class),
                data = popularity)

eq3 <- equatiomatic::extract_eq(lm3)
```


$$
\begin{aligned}
  \operatorname{popular}_{i}  &\sim N \left(\alpha_{j[i]} + \beta_{1j[i]}(\operatorname{sex}_{\operatorname{girl}}) + \beta_{2j[i]}(\operatorname{extrav}), \sigma^2 \right) \\    
\left(
  \begin{array}{c} 
    \begin{aligned}
      &\alpha_{j} \\
      &\beta_{1j} \\
      &\beta_{2j}
    \end{aligned}
  \end{array}
\right)
  &\sim N \left(
\left(
  \begin{array}{c} 
    \begin{aligned}
      &\mu_{\alpha_{j}} \\
      &\mu_{\beta_{1j}} \\
      &\mu_{\beta_{2j}}
    \end{aligned}
  \end{array}
\right)
, 
\left(
  \begin{array}{ccc}
     \sigma^2_{\alpha_{j}} & \rho_{\alpha_{j}\beta_{1j}} & \rho_{\alpha_{j}\beta_{2j}} \\ 
     \rho_{\beta_{1j}\alpha_{j}} & \sigma^2_{\beta_{1j}} & \rho_{\beta_{1j}\beta_{2j}} \\ 
     \rho_{\beta_{2j}\alpha_{j}} & \rho_{\beta_{2j}\beta_{1j}} & \sigma^2_{\beta_{2j}}
  \end{array}
\right)
 \right)
    \text{, for class j = 1,} \dots \text{,J}
\end{aligned}
$$


```{r eval=FALSE, include=FALSE, code_folding = TRUE}
m3 <- brm(popular ~ 1 + sex + extrav + (1 + sex + extrav | class),  
              prior = prior(normal(0, 2), class = b),
              data = popularity) 
```


## Cross-level interaction

Add teacher experience as a predictor. Let it interact with extraversion. This is what's known as a cross-level interaction; extraversion is a predictor of the level 1 units (pupils), whereas teacher experience is s predictor at level 2 (classes). This can be verified by looking at the dataframe---teacher experience does not have one unique value per observation, but instead for each class.


```{r eval=FALSE, include=FALSE}
lm5 <- lme4::lmer(popular ~ 1 + sex + extrav + texp + extrav:texp + 
                (1 + extrav | class),
                data = popularity)

eq5 <- equatiomatic::extract_eq(lm5)
```


$$
\begin{aligned}
  \operatorname{popular}_{i}  &\sim N \left(\alpha_{j[i]} + \beta_{1}(\operatorname{sex}_{\operatorname{girl}}) + \beta_{2j[i]}(\operatorname{extrav}), \sigma^2 \right) \\    
\left(
  \begin{array}{c} 
    \begin{aligned}
      &\alpha_{j} \\
      &\beta_{2j}
    \end{aligned}
  \end{array}
\right)
  &\sim N \left(
\left(
  \begin{array}{c} 
    \begin{aligned}
      &\gamma_{0}^{\alpha} + \gamma_{1}^{\alpha}(\operatorname{texp}) \\
      &\gamma^{\beta_{2}}_{0} + \gamma^{\beta_{2}}_{1}(\operatorname{texp})
    \end{aligned}
  \end{array}
\right)
, 
\left(
  \begin{array}{cc}
     \sigma^2_{\alpha_{j}} & \rho_{\alpha_{j}\beta_{2j}} \\ 
     \rho_{\beta_{2j}\alpha_{j}} & \sigma^2_{\beta_{2j}}
  \end{array}
\right)
 \right)
    \text{, for class j = 1,} \dots \text{,J}
\end{aligned}
$$


```{r eval=FALSE, include=TRUE, code_folding = TRUE}
model5 <- brm(popular ~ 1 + sex + extrav + texp + extrav:texp + 
                (1 + extrav | class), 
              prior = prior(normal(0, 2), class = b),
              data  = popularity)
```



:::fyi
You can attempt to decide which models fit better than others by doing posterior predictive checks.
:::
